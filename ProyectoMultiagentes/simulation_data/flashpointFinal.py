# -*- coding: utf-8 -*-
"""FlashPoint.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SnqmGQhKoHTcvb6IP_MGWeIw0DCwx0bY
"""

#!pip install mesa
#!pip install numpy
#!pip install matplotlib
#!pip install pandas
#!pip install seaborn
#!pip install IPython

from mesa import Agent, Model
from mesa.time import RandomActivation
import json
from typing import Any, Dict, List, Tuple, Optional
from mesa import Model
from mesa.time import RandomActivation
from mesa.space import SingleGrid
from typing import List, Tuple, Dict, Set
import heapq

# Acceder a los diferentes elementos del diccionario

class BomberoAgent(Agent):
    def __init__(self, unique_id: int, model: 'FlashPointModel'):
        super().__init__(unique_id, model)
        self.ap = 4  # Puntos de acción iniciales
        self.max_ap = 8  # Máximo de AP acumulables
        self.position: Tuple[int, int] = (0, 0)
        self.carrying_victim = False
        self.estrategia = "buscar_poi"  # Estrategia asignada al bombero: 'buscar_poi', 'controlar_fuego', 'quitar_humo', 'romper_pared'

    def step(self):
        if self.estrategia:
            self.ejecutar_estrategia()
        self.acumular_ap()

    def acumular_ap(self):
        self.ap = min(self.ap + 4, self.max_ap)

    def mover(self, destino: Tuple[int, int]):
        print(f"Bombero {self.unique_id} intenta moverse hacia {destino}")
        # Verificar si la celda está vacía antes de mover
        if self.model.grid.is_cell_empty(destino):
            costo = 1 if not self.model.get_cell_info(destino)["fuego"] else 2
            if self.ap >= costo:
                self.model.grid.move_agent(self, destino)
                self.position = destino
                self.ap -= costo
                print(f"Bombero {self.unique_id} se ha movido a {self.position} con {self.ap} AP restantes")
            else:
                print(f"Bombero {self.unique_id} no tiene suficientes puntos de acción para moverse. AP: {self.ap}, Costo: {costo}")
        else:
            print(f"Bombero {self.unique_id} no puede moverse a {destino}: la celda no está vacía.")

    def mover_victima(self, destino: Tuple[int, int]):
        if self.ap >= 2:
            self.model.grid.move_agent(self, destino)
            self.ap -= 2

    def abrir_puerta(self, pos: Tuple[int, int], direccion: str):
        if self.ap >= 2:
            self.model.set_door(pos, direccion)
            self.ap -= 2

    def extinguir_fuego(self, pos: Tuple[int, int]):
        if self.ap >= 2:
            self.model.extinguish_fire(pos)
            self.ap -= 2

    def destruir_pared(self, pos: Tuple[int, int], direccion: str):
        if self.ap >= 2:
            self.model.damage_wall(pos, direccion)
            self.ap -= 2

    def pasar_por_obstaculo(self, destino: Tuple[int, int]):
        if self.ap >= 1:
            self.mover(destino)
            self.ap -= 1

    def quitar_humo(self, pos: Tuple[int, int]):
        if self.ap >= 1:
            self.model.clear_smoke(pos)
            self.ap -= 1

    def ejecutar_estrategia(self):
        if self.estrategia == 'buscar_poi':
            self.estrategia_buscar_poi()
            print("estrategia POI")
            
        elif self.estrategia == 'controlar_fuego':
            self.estrategia_controlar_fuego()
            print("Ejecutar FUEGO")
            
        elif self.estrategia == 'quitar_humo':
            self.estrategia_quitar_humo()
            print("Ejecutar HUMO")
            
        elif self.estrategia == 'romper_pared':
            self.estrategia_romper_pared()
            print("Ejecutar ROMPER")

    def get_cell_info(self, pos: Tuple[int, int]) -> Dict[str, Any]:
        """Devuelve información sobre el estado de una celda específica."""
        cell_info = {
            "fuego": pos in self.fire_spots,
            "humo": pos in self.smoke_spots,
            "punto_interes": self.poi_dict.get(pos, {}).get("is_victim", False),
            "paredes": self.get_walls_info(pos),
            "puerta": self.is_doorway(pos)
        }
        return cell_info


    def estrategia_buscar_poi(self):
        poi_posiciones = [(x, y) for (x, y), poi_info in self.model.poi_dict.items() if poi_info["is_victim"]]

        if poi_posiciones:
            destino = self.buscar_celda_cercana(poi_posiciones)
            if isinstance(destino, BomberoAgent):
                destino = destino.position
            if destino:
                print(f"Bombero {self.unique_id} calcula la ruta hacia {destino}")

                # Calcular la ruta usando A* a través del modelo
                came_from, _ = self.model.a_star_search(self.position, destino)

                # Verificar si el destino está en came_from
                if destino not in came_from:
                    print(f"Error: No se encontró un camino hacia {destino}")
                    return

                # Seguir el camino hacia el POI paso a paso
                next_step = destino
                while next_step in came_from and came_from[next_step] != self.position:
                    next_step = came_from[next_step]

                # Mover al siguiente paso en el camino
                print(f"Bombero {self.unique_id} se mueve hacia la siguiente posición {next_step}")
                self.mover(next_step)
            else:
                print(f"Bombero {self.unique_id} no encontró destino cercano")
        else:
            print(f"Bombero {self.unique_id} no encontró víctimas")


    def estrategia_controlar_fuego(self):
        fuego_posiciones = [(x, y) for x in range(self.model.width)
                            for y in range(self.model.height)
                            if self.model.get_cell_info((x, y))["fuego"]]
        if fuego_posiciones:
            destino = self.buscar_celda_cercana(fuego_posiciones)
            if destino:
                self.extinguir_fuego(destino)

    def estrategia_quitar_humo(self):
        humo_posiciones = [(x, y) for x in range(self.model.width)
                           for y in range(self.model.height)
                           if self.model.get_cell_info((x, y))["humo"]]
        if humo_posiciones:
            destino = self.buscar_celda_cercana(humo_posiciones)
            if destino:
                self.quitar_humo(destino)

    def estrategia_romper_pared(self):
        for direccion, (nx, ny) in self.get_adjacent_cells(self.position).items():
            if 0 <= nx < self.model.width and 0 <= ny < self.model.height:
                celda_objetivo = self.model.get_cell_info((nx, ny))
                if celda_objetivo["punto_interes"] and not celda_objetivo["paredes"][direccion].destroyed:
                    if abs(nx - self.position[0]) + abs(ny - self.position[1]) > 4:
                        self.destruir_pared(self.position, direccion)
                        return

        self.estrategia_buscar_poi()

    def buscar_celda_cercana(self, posiciones: list) -> Optional[Tuple[int, int]]:
        min_distancia = float('inf')
        mejor_pos = None
        for pos in posiciones:
            distancia = abs(pos[0] - self.position[0]) + abs(pos[1] - self.position[1])
            if distancia < min_distancia:
                min_distancia = distancia
                mejor_pos = pos
        return mejor_pos

    def get_adjacent_cells(self, pos: Tuple[int, int]) -> dict:
        x, y = pos
        return {
            "N": (x, y + 1),
            "S": (x, y - 1),
            "E": (x + 1, y),
            "O": (x - 1, y)
        }



class FlashPointModel(Model):
    def __init__(self,width, height, wall_matrix, pois, initial_fire_positions, door_connections, exit_points, map_data, num_firefighters: int = 6):
        super().__init__()
        self.grid = SingleGrid(width, height, torus=False)
        self.schedule = RandomActivation(self)
        self.width = width
        self.height = height
        self.damage_markers = 0
        self.rescued_victims = 0
        self.lost_victims = 0
        self.victims_to_save = 7
        self.max_damage_threshold = 24
        self.fire_spots: Set[Tuple[int, int]] = set(initial_fire_positions)
        self.smoke_spots: Set[Tuple[int, int]] = set()
        self.poi_dict = {}
        self.grid_connections = {}
        self.wall_durability = {}
        self.simulation_step = 0
        self.is_running = True
        self.agents = []
        self.doorways = set(door_connections)
        self.exit_areas = set(exit_points)
        self.map_data = map_data

        # Preparar el tablero de juego
        self.setup_grid(wall_matrix)
        self.deploy_agents(num_firefighters)
        #self.place_victims(victim_positions)
        self.setup_fire(initial_fire_positions)
        for (x, y, state) in pois:
            if state == 'v':  # Si es víctima
                self.poi_dict[(int(x), int(y))] = {"is_victim": True, "revealed": False}
            elif state == 'f':  # Si es falsa alarma
                self.poi_dict[(int(x), int(y))] = {"is_victim": False, "revealed": False}

            
    def get_cell_info(self, pos: Tuple[int, int]) -> Dict[str, bool]:
        """Devuelve la información de una celda en la cuadrícula."""
        cell_info = {
            "punto_interes": pos in self.poi_dict,
            "fuego": pos in self.fire_spots,
            "humo": pos in self.smoke_spots
        }
        if pos in self.poi_dict:
            cell_info["revealed"] = self.poi_dict[pos]["revealed"]
            cell_info["is_victim"] = self.poi_dict[pos]["is_victim"]
        #print(f"Info de la celda {pos}: {cell_info}")
        return cell_info
    
    def heuristic(self, a, b):
        """Función heurística para A*, usando la distancia de Manhattan."""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def a_star_search(self, start, goal):
        """Búsqueda de A* para encontrar el camino más corto desde start a goal."""
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            _, current = heapq.heappop(frontier)
            
            print(f"Visitando nodo: {current}")

            if current == goal:
                break

            # Obtener vecinos de la posición actual
            neighbors = self.grid.get_neighbors(current, moore=False, include_center=False, radius=1)
            for next in neighbors:
                new_cost = cost_so_far[current] + 1  # Asumiendo que cada movimiento tiene un costo de 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        return came_from, cost_so_far

    def get_neighbors(self, pos):
        """Devuelve las celdas vecinas a las que el bombero puede moverse."""
        return self.grid.get_neighbors(pos, moore=False, include_center=False, radius=1)

    def setup_grid(self, wall_matrix: List[str]) -> None:
        """Prepara la estructura de la cuadrícula, asignando las paredes y las puertas."""
        self.grid_connections = self.create_grid_structure(self.width, self.height, wall_matrix)
        self.convert_walls_to_doors(self.grid_connections, self.doorways)


    def create_grid_structure(self, width: int, height: int, wall_matrix: List[str]) -> Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]]:
        """Genera la estructura de la cuadrícula basada en el esquema de paredes."""
        grid_structure = {}
        direction_vectors = [(-1, 0), (0, -1), (1, 0), (0, 1)]  # Direcciones: Norte, Oeste, Sur, Este

        for x in range(width):
            for y in range(height):
                pos = (x, y)
                adjacents = []

                wall_info = wall_matrix[y][x]

                # Verifica si wall_info tiene 4 caracteres
                if len(wall_info) != 4:
                    raise ValueError(f"wall_info en la posición {x}, {y} no tiene 4 caracteres: {wall_info}")

                for i, vector in enumerate(direction_vectors):
                    adjacent_pos = (x + vector[0], y + vector[1])
                    if 0 <= adjacent_pos[0] < width and 0 <= adjacent_pos[1] < height:
                        travel_cost = 5 if wall_info[i] == '1' else 1
                        adjacents.append((adjacent_pos, travel_cost))
                        if travel_cost == 5:
                            self.wall_durability[(pos, adjacent_pos)] = 2

                grid_structure[pos] = adjacents

        print(grid_structure.keys())
        return grid_structure
    
    def convert_walls_to_doors(self, grid_structure: Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]],
                               door_positions: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> None:
        # Filtra las posiciones de puertas que están fuera de los límites de la cuadrícula
        valid_door_positions = [
            (cell1, cell2) for (cell1, cell2) in door_positions
            # Convertir las coordenadas de cell1 y cell2 a enteros antes de la comparación
            if (0 <= int(cell1[0]) < self.width and 0 <= int(cell1[1]) < self.height) and
               (0 <= int(cell2[0]) < self.width and 0 <= int(cell2[1]) < self.height)
        ]

        for cell1, cell2 in valid_door_positions:
            # Convertir las coordenadas a enteros antes de pasar a las siguientes funciones
            cell1 = (int(cell1[0]), int(cell1[1]))
            cell2 = (int(cell2[0]), int(cell2[1]))
            self.update_travel_cost(grid_structure, cell1, cell2, 2)
            self.update_travel_cost(grid_structure, cell2, cell1, 2)



    def update_travel_cost(self, grid_structure: Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]],
                           from_pos: Tuple[int, int], to_pos: Tuple[int, int], new_cost: int) -> None:
        """Actualiza el costo de movimiento entre dos celdas en la cuadrícula."""
        for i, (adj, cost) in enumerate(grid_structure[from_pos]):
            if adj == to_pos:
                grid_structure[from_pos][i] = (adj, new_cost)
                break

    def deploy_agents(self, num_firefighters: int) -> None:
        """Despliega a los agentes bomberos en posiciones aleatorias y los coloca en la cuadrícula."""
        for i in range(num_firefighters):
            firefighter = BomberoAgent(i, self)
            while True:
                x, y = self.random.randrange(self.width), self.random.randrange(self.height)
                if self.grid.is_cell_empty((x, y)) and (x, y) not in self.fire_spots and (x, y) not in self.poi_dict:
                    break
            self.grid.place_agent(firefighter, (x, y))
            firefighter.position = (x, y)
            self.schedule.add(firefighter)
            self.agents.append(firefighter)

    def place_victims(self, victim_positions: List[Tuple[int, int, bool]]) -> None:
        """Coloca las víctimas en las posiciones iniciales en la cuadrícula."""
        for pos_x, pos_y, is_victim in victim_positions:
            pos = (pos_x, pos_y)
            self.poi_dict[pos] = {"is_victim": is_victim, "revealed": False}


    def setup_fire(self, fire_positions: List[Tuple[int, int]]) -> None:
        """Coloca las posiciones iniciales de fuego en la cuadrícula."""
        for pos in fire_positions:
            self.fire_spots.add(pos)

    def advance_simulation(self):
        """Avanza un paso en la simulación."""
        if self.is_running:
            self.spread_fire()
            
            for agent in self.schedule.agents:
                if isinstance(agent, BomberoAgent):
                    agent.ap = 4 # Si es un agente Bombero
                    agent.ejecutar_estrategia()  # Llama a su método ejecutar_estrategia
            
            self.schedule.step()
            self.evaluate_game_over_conditions()
            self.simulation_step += 1
            print("avanzar")

    def spread_fire(self) -> None:
        """Gestiona la propagación del fuego, convirtiendo humo en fuego y manejando explosiones."""    
        fire_roll = (self.random.randrange(0, self.width), self.random.randrange(0, self.height))
        self.add_smoke_or_fire(fire_roll)
        self.trigger_flashover()
        
    
    def add_smoke_or_fire(self, pos):
        """Agrega humo a una celda, o lo convierte en fuego si ya tiene humo, evitando agregar fuego si ya existe."""
        cell_key = f"Cell {pos[0]+1}{pos[1]+1}"
        cell = self.map_data.get(cell_key)

        if not cell:
            print(f"No se encontró la celda {cell_key} en map_data")
            return

        # Si ya hay fuego, no hacer nada
        if cell["fuego"] == 2:
            print(f"Ya hay fuego en {cell_key}, no se puede agregar más humo o fuego.")
            return

        if cell["fuego"] == 0:
            # Si no hay fuego ni humo, agregamos humo (fuego = 1)
            cell["fuego"] = 1
            if [pos[0], pos[1]] not in cell["coordenadas_humo"]:  # Verifica si las coordenadas ya están
                cell["coordenadas_humo"].append([pos[0], pos[1]])  # Capturamos la posición del humo
            print(f"Humo agregado en {cell_key}")
        elif cell["fuego"] == 1:
            # Si ya hay humo, lo convertimos en fuego (fuego = 2)
            cell["fuego"] = 2
            cell["coordenadas_humo"].clear()  # Eliminamos la referencia al humo
            if [pos[0], pos[1]] not in cell["coordenadas_fuego"]:  # Verifica si las coordenadas ya están
                cell["coordenadas_fuego"].append([pos[0], pos[1]])  # Agregamos la posición del fuego
            print(f"Fuego en {cell_key}")


    
    def trigger_flashover(self):
        """Simula el fenómeno de flashover donde el fuego se propaga a las celdas adyacentes."""
        for pos in list(self.fire_spots):
            neighbors = self.get_neighbors(pos)
            for neighbor in neighbors:
                cell_key = f"Cell {neighbor[0]+1}{neighbor[1]+1}"
                cell = self.map_data.get(cell_key)

                if cell and cell["fuego"] == 1:
                    # Convertir humo en fuego si hay fuego adyacente
                    cell["fuego"] = 2
                    cell["coordenadas_fuego"].append([neighbor[0], neighbor[1]])
                    cell["coordenadas_humo"].clear()  # Limpia el humo al convertirlo en fuego
                    print(f"Flashover! El fuego se propagó a {cell_key}")

    def turn_smoke_into_fire(self, pos: Tuple[int, int]) -> None:
        """Convierte el humo en fuego en una posición específica."""
        self.smoke_spots.remove(pos)
        self.fire_spots.add(pos)
        if pos in self.poi_dict:
            self.lose_victim(pos)

    def handle_explosion(self, pos: Tuple[int, int]) -> None:
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Norte, Sur, Oeste, Este

        for dx, dy in directions:
            adjacent_pos = (pos[0] + dx, pos[1] + dy)
            cell_key = f"Cell {adjacent_pos[0]}{adjacent_pos[1]}"

            # Verificar que la posición adyacente está dentro del tablero
            if 1 <= adjacent_pos[0] <= self.width and 1 <= adjacent_pos[1] <= self.height:
                cell = self.map_data.get(cell_key)
                if not cell:
                    continue

                current_fire_state = cell["fuego"]

                if current_fire_state == 0:
                    # Si la celda está vacía, agregar fuego
                    cell["fuego"] = 2  # 2 representa fuego
                    cell["coordenadas_fuego"] = [list(adjacent_pos)]
                    print(f"El fuego se ha propagado a {adjacent_pos} debido a la explosión.")
                elif current_fire_state == 1:
                    # Si la celda tiene humo, convertirlo en fuego
                    cell["fuego"] = 2
                    cell["coordenadas_fuego"] = [list(adjacent_pos)]
                    print(f"El humo en {adjacent_pos} se ha convertido en fuego debido a la explosión.")
                # Si la celda ya tiene fuego, no hacemos nada adicional

    def update_fire_in_json(self) -> None:
        """Actualiza el archivo JSON con el estado actual del fuego en el mapa."""
        # Guardar el estado actualizado del mapa en el archivo JSON
        self.save_json(self.map_data)
        print("Estado del fuego actualizado en el archivo JSON.")

    def place_fire_or_switch_smoke(self, pos: Tuple[int, int]) -> None:
        """Coloca fuego o convierte humo en fuego en una posición específica."""
        if pos in self.smoke_spots:
            self.turn_smoke_into_fire(pos)
        else:
            self.fire_spots.add(pos)
            if pos in self.poi_dict:
                self.lose_victim(pos)

    def trigger_shockwave(self, start_pos: Tuple[int, int], direction: Tuple[int, int]) -> None:
        """Propaga la onda expansiva de una explosión, afectando las celdas en la dirección dada."""
        current_pos = start_pos
        while True:
            next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
            if not self.is_valid_position(next_pos):
                break
            if next_pos not in self.fire_spots:
                if next_pos in self.smoke_spots:
                    self.turn_smoke_into_fire(next_pos)
                elif self.is_wall_between(current_pos, next_pos):
                    self.weaken_wall(current_pos, next_pos)
                    break
                elif self.is_door_between(current_pos, next_pos):
                    self.weaken_door(current_pos, next_pos)
                    break
                else:
                    self.place_fire_or_switch_smoke(next_pos)
                    break
            current_pos = next_pos

    def trigger_flashover(self) -> None:
        """Simula el fenómeno del flashover, donde el fuego se propaga al humo adyacente."""
        flashover_occurred = True
        while flashover_occurred:
            flashover_occurred = False
            for smoke_pos in list(self.smoke_spots):
                if any(self.is_adjacent(smoke_pos, fire_pos) for fire_pos in self.fire_spots):
                    self.turn_smoke_into_fire(smoke_pos)
                    flashover_occurred = True

    def lose_victim(self, pos: Tuple[int, int]) -> None:
        """Gestiona la pérdida de una víctima en una posición específica."""
        if pos in self.poi_dict:
            if self.poi_dict[pos]["is_victim"] and not self.poi_dict[pos]["revealed"]:
                self.lost_victims += 1
            del self.poi_dict[pos]

    def evaluate_game_over_conditions(self) -> None:
        """Evalúa si se ha alcanzado una condición de fin de juego."""
        if self.damage_markers >= self.max_damage_threshold:
            self.is_running = False
            print("Fin del Juego: El edificio ha colapsado.")
        elif self.lost_victims >= 4:
            self.is_running = False
            print("Fin del Juego: Se han perdido demasiadas víctimas.")
        elif self.rescued_victims >= self.victims_to_save:
            self.is_running = False
            print("Fin del Juego: Todas las víctimas han sido rescatadas.")
        elif len(self.agents) == 0:
            self.is_running = False
            print("Fin del Juego: No quedan más bomberos.")

    def is_valid_position(self, pos: Tuple[int, int]) -> bool:
        """Comprueba si una posición está dentro de los límites de la cuadrícula."""
        return 0 <= pos[0] < self.width and 0 <= pos[1] < self.height

    def is_adjacent(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:
        """Determina si dos posiciones son adyacentes en la cuadrícula."""
        # posiciones son enteros
        pos1 = (int(pos1[0]), int(pos1[1]))
        pos2 = (int(pos2[0]), int(pos2[1]))

        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1]) == 1


    def is_wall_between(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> bool:
        """Comprueba si hay una pared entre dos celdas adyacentes."""
        return any(adj == adj_pos and cost == 5 for adj, cost in self.grid_connections.get(pos, []))

    def is_door_between(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> bool:
        """Comprueba si hay una puerta entre dos celdas adyacentes."""
        return any(adj == adj_pos and cost == 2 for adj, cost in self.grid_connections.get(pos, []))

    def weaken_wall(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> None:
        """Debilita una pared entre dos celdas, eventualmente destruyéndola."""
        if self.is_wall_between(pos, adj_pos):
            wall_key = (pos, adj_pos) if (pos, adj_pos) in self.wall_durability else (adj_pos, pos)
            self.wall_durability[wall_key] -= 1
            self.damage_markers += 1
            if self.wall_durability[wall_key] == 0:
                self.update_travel_cost(self.grid_connections, pos, adj_pos, 1)
                self.update_travel_cost(self.grid_connections, adj_pos, pos, 1)
                del self.wall_durability[wall_key]
                print(f"La pared entre {pos} y {adj_pos} ha sido destruida.")

    def weaken_door(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> None:
        """Debilita una puerta entre dos celdas, eventualmente convirtiéndola en un camino abierto."""
        if self.is_door_between(pos, adj_pos):
            self.update_travel_cost(self.grid_connections, pos, adj_pos, 1)
            self.update_travel_cost(self.grid_connections, adj_pos, pos, 1)

    def get_simulation_state(self) -> Dict:
        """Devuelve el estado actual de la simulación."""
        return {
            "step": self.simulation_step,
            "grid_connections": self.grid_connections,
            "damage_markers": self.damage_markers,
            "rescued_victims": self.rescued_victims,
            "lost_victims": self.lost_victims,
            "running": self.is_running,
            "fire_locations": list(self.fire_spots),
            "smoke_locations": list(self.smoke_spots),
            "poi_locations": [{"position": pos, "revealed": info["revealed"]} for pos, info in self.poi_dict.items()],
            "firefighter_positions": [{"id": agent.unique_id, "position": agent.position, "carrying_victim": agent.carrying_victim} for agent in self.agents if isinstance(agent, BomberoAgent)]
        }
        
        
        
        

import json
import time

def save_json(map_data):
    # Guarda el JSON en un archivo (sobrescribiendo en cada paso)
    with open('simulation_state.json', 'w') as outfile:
        json.dump(map_data, outfile)
    print("Estado del mapa guardado en simulation_state.json")

def main():
    
    class Cell():
        def __init__(self, x, y, wall):
            self.pos = (x, y)
            self.up = wall[0] == '1'
            self.left = wall[1] == '1'
            self.down = wall[2] == '1'
            self.right = wall[3] == '1'
            self.poi = 0
            self.fire = 0
            self.door = []
    

            self.entrance = False #Entrada
    

    with open('tablero.txt', 'r') as map_file:
        text = map_file.read().splitlines()
    
    walls = []
    for line in text[:6]:
        wall_segments = line.split()
        walls.extend(wall_segments)
    walls2 = walls[:]
    wall_matrix = [walls[i:i + 8] for i in range(0, len(walls), 8)]

    print(f"Dimensiones de wall_matrix: {len(wall_matrix)} filas, cada fila tiene {len(wall_matrix[0])} columnas")

    pois = []
    for line in text[6:9]:
        pos_poi_x = line[0]
        pos_poi_y = line[2]
        pos_poi_state = line[4]
        pois.append((pos_poi_x, pos_poi_y, pos_poi_state))
    
    fires = []
    for line in text[9:19]:
        pos_fire_x = line[0]
        pos_fire_y = line[2]
        fires.append((pos_fire_x, pos_fire_y))
    
    doors = []
    for line in text[19:27]:
        pos_doorA_x = line[0]
        pos_doorA_y = line[2]
        pos_doorB_x = line[4]
        pos_doorB_y = line[6]
        doors.append(((pos_doorA_x, pos_doorA_y), (pos_doorB_x, pos_doorB_y)))

    entrances = []
    for line in text[27:]:
        pos_entrance_x = line[0]
        pos_entrance_y = line[2]
        entrances.append((pos_entrance_x, pos_entrance_y))
        
    cells = []
    for i in range(6):
        for j in range(8):
            w = walls.pop(0)
            c = Cell(i + 1, j + 1, w)
            cells.append(c)
    
            if (str(i + 1), str(j + 1), 'v') in pois:
                c.poi = 2
            elif (str(i + 1), str(j + 1), 'f') in pois:
                c.poi = 1
    
            if (str(i + 1), str(j + 1)) in fires:
                c.fire = 2
    
            for d in doors:
                if (str(i + 1), str(j + 1)) == d[0]:
                    c.door = d[1]
    
            if (str(i + 1), str(j + 1)) in entrances:
                c.entrance = True
    
    map_data = {}
    
    for c in cells:
        cell_key = f"Cell {c.pos[0]}{c.pos[1]}"
        
        if cell_key not in map_data:
            map_data[cell_key] = {
                "posicion_x": c.pos[0],
                "posicion_y": c.pos[1],
                "muro_arriba": c.up,
                "muro_izquierda": c.left,
                "muro_abajo": c.down,
                "muro_derecha": c.right,
                "punto_interes": c.poi,
                "fuego": c.fire,
                "puerta": c.door,
                "entrada": c.entrance,
                "coordenadas_poi": [],
                "coordenadas_victimas": [],
                "coordenadas_fuego": [],
                "coordenadas_entradas": [],
                "coordenadas_humo":[]
            }
        
        if c.poi == 2:
            map_data[cell_key]["coordenadas_victimas"].append(c.pos)
            map_data[cell_key]["coordenadas_poi"].append(c.pos)
        elif c.poi == 1:  
            if map_data[cell_key]["fuego"] == 0 and not map_data[cell_key]["coordenadas_victimas"]:
                map_data[cell_key]["coordenadas_poi"].append(c.pos)
        
        if c.fire == 2:
            map_data[cell_key]["coordenadas_fuego"].append(c.pos)
        
        if c.entrance:
            map_data[cell_key]["coordenadas_entradas"].append(c.pos)
    
    GRID_WIDTH = 8
    GRID_HEIGHT = 6
    # Inicializar el modelo con los datos extraídos
    print("paredes ", walls2)

    model = FlashPointModel(GRID_WIDTH, GRID_HEIGHT, wall_matrix, pois, fires, doors, entrances, map_data)
    # Procesa el archivo del mapa
    #map_data = process_map_file('tablero.txt')

    # Correr la simulación por 100 pasos
    for step in range(100):
        game_state = model.advance_simulation()  # Aquí avanza la simulación
        print(f"Estado del juego en el paso {step + 1}:")
        
        # Obtén el estado actual del tablero
        current_state = model.get_simulation_state()

        # Integra la posición de los bomberos en el mapa
        for firefighter in current_state['firefighter_positions']:
            firefighter_id = firefighter['id']
            position = firefighter['position']
            carrying_victim = firefighter['carrying_victim']
            print(f"Bombero {firefighter_id}: posición actual {position}")
            
            # Agrega las posiciones al JSON del mapa (puedes ajustar según cómo estructures el JSON)
            map_data[f"Firefighter_{firefighter_id}"] = {
                "posicion_x": position[0],
                "posicion_y": position[1],
                "carrying_victim": carrying_victim
            }

        # Guarda el estado actualizado de la simulación en formato JSON
        save_json(map_data)

        # Pausa entre pasos (si es necesario)
        time.sleep(1)
        if not model.is_running:
            break

if __name__ == "__main__":
    main()
