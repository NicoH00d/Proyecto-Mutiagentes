# -*- coding: utf-8 -*-
"""FlashPoint.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SnqmGQhKoHTcvb6IP_MGWeIw0DCwx0bY
"""

#!pip install mesa
#!pip install numpy
#!pip install matplotlib
#!pip install pandas
#!pip install seaborn
#!pip install IPython


#Importar las librerías necesarias para el funcionamiento del modelo
from mesa import Agent, Model
from mesa.time import RandomActivation
import json
from typing import Any, Dict, List, Tuple, Optional
from mesa import Model
from mesa.time import RandomActivation
from mesa.space import SingleGrid
from typing import List, Tuple, Dict, Set
import heapq

#Definir la clase BomberoAgent
class BomberoAgent(Agent):
    def __init__(self, unique_id: int, model: 'FlashPointModel'):
        super().__init__(unique_id, model)
        self.ap = 4  
        self.max_ap = 8  
        self.position: Tuple[int, int] = (0, 0)
        self.carrying_victim = False
        self.estrategia = "buscar_poi"  

#Definir el método step donde ejecuta la estrategia y acumula puntos de acción si es necesario
    def step(self):
        if self.estrategia:
            self.ejecutar_estrategia()
        self.acumular_ap()

#Definir el método acumular_ap que acumula puntos de acción en dado caso de ser necesario
    def acumular_ap(self):
        self.ap = min(self.ap + 4, self.max_ap)

#Definir el método mover que permite mover al bombero a una celda específica
    def mover(self, destino: Tuple[int, int]):
        print(f"Bombero {self.unique_id} intenta moverse hacia {destino}")

        # Verificar si la celda está vacía antes de mover
        if self.model.grid.is_cell_empty(destino):
            costo = 1 if not self.model.get_cell_info(destino)["fuego"] else 2
            if self.ap >= costo:
                self.model.grid.move_agent(self, destino)
                self.position = destino
                self.ap -= costo
                print(f"Bombero {self.unique_id} se ha movido a {self.position} con {self.ap} AP restantes")
            else:
                print(f"Bombero {self.unique_id} no tiene suficientes puntos de acción para moverse. AP: {self.ap}, Costo: {costo}")
        else:
            print(f"Bombero {self.unique_id} no puede moverse a {destino}: la celda no está vacía.")

#Definir el método mover_victima que permite mover a una víctima a una celda específica
    def mover_victima(self, destino: Tuple[int, int]):
        if self.ap >= 2:
            self.model.grid.move_agent(self, destino)
            self.ap -= 2
#Definir el método rescatar_victima que permite rescatar a una víctima
    def abrir_puerta(self, pos: Tuple[int, int], direccion: str):
        if self.ap >= 2:
            self.model.set_door(pos, direccion)
            self.ap -= 2

#Definir el método extinguir_fuego que permite extinguir el fuego en una celda específica
    def extinguir_fuego(self, pos: Tuple[int, int]):
        if self.ap >= 2:
            self.model.extinguish_fire(pos)
            self.ap -= 2

#Definir el método destruir_pared que permite destruir una pared en una celda específica
    def destruir_pared(self, pos: Tuple[int, int], direccion: str):
        if self.ap >= 2:
            self.model.damage_wall(pos, direccion)
            self.ap -= 2

#Definir el método pasar_por_obstaculo que permite pasar por un obstáculo en una celda específica
    def pasar_por_obstaculo(self, destino: Tuple[int, int]):
        if self.ap >= 1:
            self.mover(destino)
            self.ap -= 1

#Definir el método quitar_humo que permite quitar el humo en una celda específica
    def quitar_humo(self, pos: Tuple[int, int]):
        if self.ap >= 1:
            self.model.clear_smoke(pos)
            self.ap -= 1

#Definir la funcion ejecutar_estrategia que permite ejecutar una estrategia específica
    def ejecutar_estrategia(self):
        if self.estrategia == 'buscar_poi':
            self.estrategia_buscar_poi()
            print("estrategia POI")
            
        elif self.estrategia == 'controlar_fuego':
            self.estrategia_controlar_fuego()
            print("Ejecutar FUEGO")
            
        elif self.estrategia == 'quitar_humo':
            self.estrategia_quitar_humo()
            print("Ejecutar HUMO")
            
        elif self.estrategia == 'romper_pared':
            self.estrategia_romper_pared()
            print("Ejecutar ROMPER")

#Definir el método get_walls_info que permite obtener información sobre las paredes en una celda específica
    def get_cell_info(self, pos: Tuple[int, int]) -> Dict[str, Any]:
        """Devuelve información sobre el estado de una celda específica."""
        cell_info = {
            "fuego": pos in self.fire_spots,
            "humo": pos in self.smoke_spots,
            "punto_interes": self.poi_dict.get(pos, {}).get("is_victim", False),
            "paredes": self.get_walls_info(pos),
            "puerta": self.is_doorway(pos)
        }
        return cell_info

#Definir la funcion estrategia_buscar_poi que permite buscar un punto de interés
    def estrategia_buscar_poi(self):
        poi_posiciones = [(x, y) for (x, y), poi_info in self.model.poi_dict.items() if poi_info["is_victim"]]


        if poi_posiciones:
            destino = self.buscar_celda_cercana(poi_posiciones)
            if isinstance(destino, BomberoAgent):
                destino = destino.position
            if destino:
                print(f"Bombero {self.unique_id} calcula la ruta hacia {destino}")

                came_from, _ = self.model.a_star_search(self.position, destino)

                if destino not in came_from:
                    print(f"Error: No se encontró un camino hacia {destino}")
                    return

                next_step = destino
                while next_step in came_from and came_from[next_step] != self.position:
                    next_step = came_from[next_step]

                print(f"Bombero {self.unique_id} se mueve hacia la siguiente posición {next_step}")
                self.mover(next_step)
            else:
                print(f"Bombero {self.unique_id} no encontró destino cercano")
        else:
            print(f"Bombero {self.unique_id} no encontró víctimas")

#Definir la función estrategia_controlar_fuego que permite controlar el fuego en una celda específica
    def estrategia_controlar_fuego(self):
        fuego_posiciones = [(x, y) for x in range(self.model.width)
                            for y in range(self.model.height)
                            if self.model.get_cell_info((x, y))["fuego"]]
        if fuego_posiciones:
            destino = self.buscar_celda_cercana(fuego_posiciones)
            if destino:
                self.extinguir_fuego(destino)

#Definir la función estrategia_quitar_humo que permite quitar el humo en una celda específica
    def estrategia_quitar_humo(self):
        humo_posiciones = [(x, y) for x in range(self.model.width)
                           for y in range(self.model.height)
                           if self.model.get_cell_info((x, y))["humo"]]
        if humo_posiciones:
            destino = self.buscar_celda_cercana(humo_posiciones)
            if destino:
                self.quitar_humo(destino)

#Definir la función estrategia_romper_pared que permite romper una pared en una celda específica
    def estrategia_romper_pared(self):
        for direccion, (nx, ny) in self.get_adjacent_cells(self.position).items():
            if 0 <= nx < self.model.width and 0 <= ny < self.model.height:
                celda_objetivo = self.model.get_cell_info((nx, ny))
                if celda_objetivo["punto_interes"] and not celda_objetivo["paredes"][direccion].destroyed:
                    if abs(nx - self.position[0]) + abs(ny - self.position[1]) > 4:
                        self.destruir_pared(self.position, direccion)
                        return

        self.estrategia_buscar_poi()

#Definir la función buscar_celda_cercana que permite buscar una celda cercana
    def buscar_celda_cercana(self, posiciones: list) -> Optional[Tuple[int, int]]:
        min_distancia = float('inf')
        mejor_pos = None
        for pos in posiciones:
            distancia = abs(pos[0] - self.position[0]) + abs(pos[1] - self.position[1])
            if distancia < min_distancia:
                min_distancia = distancia
                mejor_pos = pos
        return mejor_pos

#Definir la función get_adjacent_cells que permite obtener las celdas adyacentes a una celda específica
    def get_adjacent_cells(self, pos: Tuple[int, int]) -> dict:
        x, y = pos
        return {
            "N": (x, y + 1),
            "S": (x, y - 1),
            "E": (x + 1, y),
            "O": (x - 1, y)
        }


#Definir la clase FlashPointModel nucleo del modelo
class FlashPointModel(Model):
    def __init__(self,width, height, wall_matrix, pois, initial_fire_positions, door_connections, exit_points, map_data, num_firefighters: int = 6):
        super().__init__()
        self.grid = SingleGrid(width, height, torus=False)
        self.schedule = RandomActivation(self)
        self.width = width
        self.height = height
        self.damage_markers = 0
        self.rescued_victims = 0
        self.lost_victims = 0
        self.victims_to_save = 7
        self.max_damage_threshold = 24
        self.fire_spots: Set[Tuple[int, int]] = set(initial_fire_positions)
        self.smoke_spots: Set[Tuple[int, int]] = set()
        self.poi_dict = {}
        self.grid_connections = {}
        self.wall_durability = {}
        self.simulation_step = 0
        self.is_running = True
        self.agents = []
        self.doorways = set(door_connections)
        self.exit_areas = set(exit_points)
        self.map_data = map_data

        self.setup_grid(wall_matrix)
        self.deploy_agents(num_firefighters)
        self.setup_fire(initial_fire_positions)
        for (x, y, state) in pois:
            if state == 'v':  # Si es víctima
                self.poi_dict[(int(x), int(y))] = {"is_victim": True, "revealed": False}
            elif state == 'f':  # Si es falsa alarma
                self.poi_dict[(int(x), int(y))] = {"is_victim": False, "revealed": False}

#Definir el método get_cell_info que permite obtener información de una celda específica     
    def get_cell_info(self, pos: Tuple[int, int]) -> Dict[str, bool]:
        """Devuelve la información de una celda en la cuadrícula."""
        cell_info = {
            "punto_interes": pos in self.poi_dict,
            "fuego": pos in self.fire_spots,
            "humo": pos in self.smoke_spots
        }
        if pos in self.poi_dict:
            cell_info["revealed"] = self.poi_dict[pos]["revealed"]
            cell_info["is_victim"] = self.poi_dict[pos]["is_victim"]
        return cell_info
    
    def heuristic(self, a, b):
        """Función heurística para A*, usando la distancia de Manhattan."""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def a_star_search(self, start, goal):
        """Búsqueda de A* para encontrar el camino más corto desde start a goal."""
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            _, current = heapq.heappop(frontier)
            
            print(f"Visitando nodo: {current}")

            if current == goal:
                break

            neighbors = self.grid.get_neighbors(current, moore=False, include_center=False, radius=1)
            for next in neighbors:
                new_cost = cost_so_far[current] + 1  # Asumiendo que cada movimiento tiene un costo de 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        return came_from, cost_so_far

#Definir el método get_neighbors que permite obtener las celdas vecinas a una celda específica
    def get_neighbors(self, pos):
        """Devuelve las celdas vecinas a las que el bombero puede moverse."""
        return self.grid.get_neighbors(pos, moore=False, include_center=False, radius=1)

#Definir la funcion setup_grid que permite preparar la cuadrícula
    def setup_grid(self, wall_matrix: List[str]) -> None:
        """Prepara la estructura de la cuadrícula, asignando las paredes y las puertas."""
        self.grid_connections = self.create_grid_structure(self.width, self.height, wall_matrix)
        self.convert_walls_to_doors(self.grid_connections, self.doorways)

#Definir la función create_grid_structure que permite crear la estructura de la cuadrícula
    def create_grid_structure(self, width: int, height: int, wall_matrix: List[str]) -> Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]]:
        """Genera la estructura de la cuadrícula basada en el esquema de paredes."""
        grid_structure = {}
        direction_vectors = [(-1, 0), (0, -1), (1, 0), (0, 1)]  # Direcciones: Norte, Oeste, Sur, Este

        for x in range(width):
            for y in range(height):
                pos = (x, y)
                adjacents = []

                wall_info = wall_matrix[y][x]

                if len(wall_info) != 4:
                    raise ValueError(f"wall_info en la posición {x}, {y} no tiene 4 caracteres: {wall_info}")

                for i, vector in enumerate(direction_vectors):
                    adjacent_pos = (x + vector[0], y + vector[1])
                    if 0 <= adjacent_pos[0] < width and 0 <= adjacent_pos[1] < height:
                        travel_cost = 5 if wall_info[i] == '1' else 1
                        adjacents.append((adjacent_pos, travel_cost))
                        if travel_cost == 5:
                            self.wall_durability[(pos, adjacent_pos)] = 2

                grid_structure[pos] = adjacents

        print(grid_structure.keys())
        return grid_structure
    
#Definir la función convert_walls_to_doors que permite convertir las paredes en puertas
    def convert_walls_to_doors(self, grid_structure: Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]],
                               door_positions: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> None:
        valid_door_positions = [
            (cell1, cell2) for (cell1, cell2) in door_positions
            if (0 <= int(cell1[0]) < self.width and 0 <= int(cell1[1]) < self.height) and
               (0 <= int(cell2[0]) < self.width and 0 <= int(cell2[1]) < self.height)
        ]

        for cell1, cell2 in valid_door_positions:
            cell1 = (int(cell1[0]), int(cell1[1]))
            cell2 = (int(cell2[0]), int(cell2[1]))
            self.update_travel_cost(grid_structure, cell1, cell2, 2)
            self.update_travel_cost(grid_structure, cell2, cell1, 2)

#Definir la funcion update_travel_cost que permite actualizar el costo de movimiento entre dos celdas
    def update_travel_cost(self, grid_structure: Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]],
                           from_pos: Tuple[int, int], to_pos: Tuple[int, int], new_cost: int) -> None:
        """Actualiza el costo de movimiento entre dos celdas en la cuadrícula."""
        for i, (adj, cost) in enumerate(grid_structure[from_pos]):
            if adj == to_pos:
                grid_structure[from_pos][i] = (adj, new_cost)
                break

#Definir la funcion deploy_agents que permite desplegar a los agentes en la cuadrícula
    def deploy_agents(self, num_firefighters: int) -> None:
        """Despliega a los agentes bomberos en posiciones aleatorias y los coloca en la cuadrícula."""
        for i in range(num_firefighters):
            firefighter = BomberoAgent(i, self)
            while True:
                x, y = self.random.randrange(self.width), self.random.randrange(self.height)
                if self.grid.is_cell_empty((x, y)) and (x, y) not in self.fire_spots and (x, y) not in self.poi_dict:
                    break
            self.grid.place_agent(firefighter, (x, y))
            firefighter.position = (x, y)
            self.schedule.add(firefighter)
            self.agents.append(firefighter)

#Definir la función place_victims que permite colocar a las víctimas en la cuadrícula
    def place_victims(self, victim_positions: List[Tuple[int, int, bool]]) -> None:
        """Coloca las víctimas en las posiciones iniciales en la cuadrícula."""
        for pos_x, pos_y, is_victim in victim_positions:
            pos = (pos_x, pos_y)
            self.poi_dict[pos] = {"is_victim": is_victim, "revealed": False}

#Definir la función setup_fire que permite colocar las posiciones iniciales de fuego en la cuadrícula
    def setup_fire(self, fire_positions: List[Tuple[int, int]]) -> None:
        """Coloca las posiciones iniciales de fuego en la cuadrícula."""
        for pos in fire_positions:
            self.fire_spots.add(pos)

#Definir la funcion advance_simulation que permite avanzar un paso en la simulación
    def advance_simulation(self):
        """Avanza un paso en la simulación."""
        if self.is_running:
            self.spread_fire()
            
            for agent in self.schedule.agents:
                if isinstance(agent, BomberoAgent):
                    agent.ap = 4 
                    agent.ejecutar_estrategia()  
            
            self.schedule.step()
            self.evaluate_game_over_conditions()
            self.simulation_step += 1
            print("avanzar")

#Definir la función spread_fire que permite propagar el fuego en la cuadrícula
    def spread_fire(self) -> None:
        """Gestiona la propagación del fuego, convirtiendo humo en fuego y manejando explosiones."""    
        fire_roll = (self.random.randrange(0, self.width), self.random.randrange(0, self.height))
        self.add_smoke_or_fire(fire_roll)
        self.trigger_flashover()   
    
#Definir la función add_smoke_or_fire que permite agregar humo o fuego en una celda específica
    def add_smoke_or_fire(self, pos):
        """Agrega humo a una celda, o lo convierte en fuego si ya tiene humo, evitando agregar fuego si ya existe."""
        cell_key = f"Cell {pos[0]+1}{pos[1]+1}"
        cell = self.map_data.get(cell_key)

        if not cell:
            print(f"No se encontró la celda {cell_key} en map_data")
            return

        if cell["fuego"] == 2:
            print(f"Ya hay fuego en {cell_key}, no se puede agregar más humo o fuego.")
            return

        if cell["fuego"] == 0:
            cell["fuego"] = 1
            if [pos[0], pos[1]] not in cell["coordenadas_humo"]: 
                cell["coordenadas_humo"].append([pos[0], pos[1]])  
            print(f"Humo agregado en {cell_key}")
        elif cell["fuego"] == 1:
            
            cell["fuego"] = 2
            cell["coordenadas_humo"].clear()  
            if [pos[0], pos[1]] not in cell["coordenadas_fuego"]:  
                cell["coordenadas_fuego"].append([pos[0], pos[1]]) 
            print(f"Fuego en {cell_key}")

#Definir la función trigger_flashover que permite simular el fenómeno de flashover
    def trigger_flashover(self):
        """Simula el fenómeno de flashover donde el fuego se propaga a las celdas adyacentes."""
        for pos in list(self.fire_spots):
            neighbors = self.get_neighbors(pos)
            for neighbor in neighbors:
                cell_key = f"Cell {neighbor[0]+1}{neighbor[1]+1}"
                cell = self.map_data.get(cell_key)

                if cell and cell["fuego"] == 1:
                    cell["fuego"] = 2
                    cell["coordenadas_fuego"].append([neighbor[0], neighbor[1]])
                    cell["coordenadas_humo"].clear()  
                    print(f"Flashover! El fuego se propagó a {cell_key}")

#Definir funcion turn_smoke_into_fire que permite convertir el humo en fuego en una celda específica
    def turn_smoke_into_fire(self, pos: Tuple[int, int]) -> None:
        """Convierte el humo en fuego en una posición específica."""
        self.smoke_spots.remove(pos)
        self.fire_spots.add(pos)
        if pos in self.poi_dict:
            self.lose_victim(pos)

#Definir funcion handle_explosion que permite manejar una explosión en una celda específica
    def handle_explosion(self, pos: Tuple[int, int]) -> None:
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Norte, Sur, Oeste, Este

        for dx, dy in directions:
            adjacent_pos = (pos[0] + dx, pos[1] + dy)
            cell_key = f"Cell {adjacent_pos[0]}{adjacent_pos[1]}"

            # Verificar que la posición adyacente está dentro del tablero
            if 1 <= adjacent_pos[0] <= self.width and 1 <= adjacent_pos[1] <= self.height:
                cell = self.map_data.get(cell_key)
                if not cell:
                    continue

                current_fire_state = cell["fuego"]

                if current_fire_state == 0:
                    # Si la celda está vacía, agregar fuego
                    cell["fuego"] = 2  
                    cell["coordenadas_fuego"] = [list(adjacent_pos)]
                    print(f"El fuego se ha propagado a {adjacent_pos} debido a la explosión.")
                elif current_fire_state == 1:
                    # Si la celda tiene humo, convertirlo en fuego
                    cell["fuego"] = 2
                    cell["coordenadas_fuego"] = [list(adjacent_pos)]
                    print(f"El humo en {adjacent_pos} se ha convertido en fuego debido a la explosión.")

#Definir funcion update_fire_in_json que permite actualizar el estado del fuego en el archivo JSON
    def update_fire_in_json(self) -> None:
        """Actualiza el archivo JSON con el estado actual del fuego en el mapa."""
        self.save_json(self.map_data)
        print("Estado del fuego actualizado en el archivo JSON.")

#Definir funcion place_fire_or_switch_smoke que permite colocar fuego o convertir humo en fuego en una celda específica
    def place_fire_or_switch_smoke(self, pos: Tuple[int, int]) -> None:
        """Coloca fuego o convierte humo en fuego en una posición específica."""
        if pos in self.smoke_spots:
            self.turn_smoke_into_fire(pos)
        else:
            self.fire_spots.add(pos)
            if pos in self.poi_dict:
                self.lose_victim(pos)

#Definir funcion shockwave que permite propagar una onda expansiva en una dirección específica
    def trigger_shockwave(self, start_pos: Tuple[int, int], direction: Tuple[int, int]) -> None:
        current_pos = start_pos
        while True:
            next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
            if not self.is_valid_position(next_pos):
                break
            if next_pos not in self.fire_spots:
                if next_pos in self.smoke_spots:
                    self.turn_smoke_into_fire(next_pos)
                elif self.is_wall_between(current_pos, next_pos):
                    self.weaken_wall(current_pos, next_pos)
                    break
                elif self.is_door_between(current_pos, next_pos):
                    self.weaken_door(current_pos, next_pos)
                    break
                else:
                    self.place_fire_or_switch_smoke(next_pos)
                    break
            current_pos = next_pos

#Definir funcion flashover que permite simular el fenómeno de flashover
    def trigger_flashover(self) -> None:
        flashover_occurred = True
        while flashover_occurred:
            flashover_occurred = False
            for smoke_pos in list(self.smoke_spots):
                if any(self.is_adjacent(smoke_pos, fire_pos) for fire_pos in self.fire_spots):
                    self.turn_smoke_into_fire(smoke_pos)
                    flashover_occurred = True

#Definir lose_victim que permite perder una víctima en una celda específica
    def lose_victim(self, pos: Tuple[int, int]) -> None:
        if pos in self.poFi_dict:
            if self.poi_dict[pos]["is_victim"] and not self.poi_dict[pos]["revealed"]:
                self.lost_victims += 1
            del self.poi_dict[pos]

#Definir evaluate_game_over_conditions que permite evaluar las condiciones de fin de juego
    def evaluate_game_over_conditions(self) -> None:
        if self.damage_markers >= self.max_damage_threshold:
            self.is_running = False
            print("Fin del Juego: El edificio ha colapsado.")
        elif self.lost_victims >= 4:
            self.is_running = False
            print("Fin del Juego: Se han perdido demasiadas víctimas.")
        elif self.rescued_victims >= self.victims_to_save:
            self.is_running = False
            print("Fin del Juego: Todas las víctimas han sido rescatadas.")
        elif len(self.agents) == 0:
            self.is_running = False
            print("Fin del Juego: No quedan más bomberos.")

#Definir is_valid_position que permite verificar si una posición es válida
    def is_valid_position(self, pos: Tuple[int, int]) -> bool:
        return 0 <= pos[0] < self.width and 0 <= pos[1] < self.height

    def is_adjacent(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:
        pos1 = (int(pos1[0]), int(pos1[1]))
        pos2 = (int(pos2[0]), int(pos2[1]))

        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1]) == 1

#Definir is_wall_between que permite verificar si hay una pared entre dos celdas
    def is_wall_between(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> bool:
        return any(adj == adj_pos and cost == 5 for adj, cost in self.grid_connections.get(pos, []))

#Definir is_door_between que permite verificar si hay una puerta entre dos celdas
    def is_door_between(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> bool:
        return any(adj == adj_pos and cost == 2 for adj, cost in self.grid_connections.get(pos, []))

#Definir weaken_wall que permite debilitar una pared entre dos celdas
    def weaken_wall(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> None:
        if self.is_wall_between(pos, adj_pos):
            wall_key = (pos, adj_pos) if (pos, adj_pos) in self.wall_durability else (adj_pos, pos)
            self.wall_durability[wall_key] -= 1
            self.damage_markers += 1
            if self.wall_durability[wall_key] == 0:
                self.update_travel_cost(self.grid_connections, pos, adj_pos, 1)
                self.update_travel_cost(self.grid_connections, adj_pos, pos, 1)
                del self.wall_durability[wall_key]
                print(f"La pared entre {pos} y {adj_pos} ha sido destruida.")

#Definir weaken_door que permite debilitar una puerta entre dos celdas
    def weaken_door(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> None:
        if self.is_door_between(pos, adj_pos):
            self.update_travel_cost(self.grid_connections, pos, adj_pos, 1)
            self.update_travel_cost(self.grid_connections, adj_pos, pos, 1)

#Definir get_simulation_state que permite obtener el estado de la simulación
    def get_simulation_state(self) -> Dict:
        return {
            "step": self.simulation_step,
            "grid_connections": self.grid_connections,
            "damage_markers": self.damage_markers,
            "rescued_victims": self.rescued_victims,
            "lost_victims": self.lost_victims,
            "running": self.is_running,
            "fire_locations": list(self.fire_spots),
            "smoke_locations": list(self.smoke_spots),
            "poi_locations": [{"position": pos, "revealed": info["revealed"]} for pos, info in self.poi_dict.items()],
            "firefighter_positions": [{"id": agent.unique_id, "position": agent.position, "carrying_victim": agent.carrying_victim} for agent in self.agents if isinstance(agent, BomberoAgent)]
        }
        
import json
import time

def save_json(map_data):
    with open('simulation_state.json', 'w') as outfile:
        json.dump(map_data, outfile)
    print("Estado del mapa guardado en simulation_state.json")

def main():
    class Cell():
        def __init__(self, x, y, wall):
            # posición
            self.pos = (x, y)
    
            self.up = wall[0] == '1'
            self.left = wall[1] == '1'
            self.down = wall[2] == '1'
            self.right = wall[3] == '1'
    
            self.poi = 0
    
            self.fire = 0
    
            self.door = []
    
            self.entrance = False
    
    with open('tablero.txt', 'r') as map_file:
        text = map_file.read().splitlines()
    
    walls = []
    for line in text[:6]:
        wall_segments = line.split()
        walls.extend(wall_segments)
    walls2 = walls[:]
    wall_matrix = [walls[i:i + 8] for i in range(0, len(walls), 8)]

    print(f"Dimensiones de wall_matrix: {len(wall_matrix)} filas, cada fila tiene {len(wall_matrix[0])} columnas")

    
    pois = []
    for line in text[6:9]:
        pos_poi_x = line[0]
        pos_poi_y = line[2]
        pos_poi_state = line[4]
        pois.append((pos_poi_x, pos_poi_y, pos_poi_state))
    
    fires = []
    for line in text[9:19]:
        pos_fire_x = line[0]
        pos_fire_y = line[2]
        fires.append((pos_fire_x, pos_fire_y))
    
    doors = []
    for line in text[19:27]:
        pos_doorA_x = line[0]
        pos_doorA_y = line[2]
        pos_doorB_x = line[4]
        pos_doorB_y = line[6]
        doors.append(((pos_doorA_x, pos_doorA_y), (pos_doorB_x, pos_doorB_y)))
    
    entrances = []
    for line in text[27:]:
        pos_entrance_x = line[0]
        pos_entrance_y = line[2]
        entrances.append((pos_entrance_x, pos_entrance_y))
        
    cells = []
    for i in range(6):
        for j in range(8):
            w = walls.pop(0)
            c = Cell(i + 1, j + 1, w)
            cells.append(c)
    
            if (str(i + 1), str(j + 1), 'v') in pois:
                c.poi = 2
            elif (str(i + 1), str(j + 1), 'f') in pois:
                c.poi = 1
    
            if (str(i + 1), str(j + 1)) in fires:
                c.fire = 2
    
            for d in doors:
                if (str(i + 1), str(j + 1)) == d[0]:
                    c.door = d[1]
    
            if (str(i + 1), str(j + 1)) in entrances:
                c.entrance = True
        map_data = {}
    
    for c in cells:
        cell_key = f"Cell {c.pos[0]}{c.pos[1]}"
        
        if cell_key not in map_data:
            map_data[cell_key] = {
                "posicion_x": c.pos[0],
                "posicion_y": c.pos[1],
                "muro_arriba": c.up,
                "muro_izquierda": c.left,
                "muro_abajo": c.down,
                "muro_derecha": c.right,
                "punto_interes": c.poi,
                "fuego": c.fire,
                "puerta": c.door,
                "entrada": c.entrance,
                "coordenadas_poi": [],
                "coordenadas_victimas": [],
                "coordenadas_fuego": [],
                "coordenadas_entradas": [],
                "coordenadas_humo":[]
            }
        
        if c.poi == 2: 
            map_data[cell_key]["coordenadas_victimas"].append(c.pos)
            map_data[cell_key]["coordenadas_poi"].append(c.pos)
        elif c.poi == 1:  
            if map_data[cell_key]["fuego"] == 0 and not map_data[cell_key]["coordenadas_victimas"]:
                map_data[cell_key]["coordenadas_poi"].append(c.pos)
        
        if c.fire == 2: 
            map_data[cell_key]["coordenadas_fuego"].append(c.pos)
        
        if c.entrance:
            map_data[cell_key]["coordenadas_entradas"].append(c.pos)
    
    GRID_WIDTH = 8
    GRID_HEIGHT = 6
    print("paredes ", walls2)

    model = FlashPointModel(GRID_WIDTH, GRID_HEIGHT, wall_matrix, pois, fires, doors, entrances, map_data)
    # Procesa el archivo del mapa
    #map_data = process_map_file('tablero.txt')

    # Correr la simulación por 100 pasos
    for step in range(100):
        game_state = model.advance_simulation()  # Aquí avanza la simulación
        print(f"Estado del juego en el paso {step + 1}:")
        
        # Obtén el estado actual del tablero
        current_state = model.get_simulation_state()

        # Integra la posición de los bomberos en el mapa
        for firefighter in current_state['firefighter_positions']:
            firefighter_id = firefighter['id']
            position = firefighter['position']
            carrying_victim = firefighter['carrying_victim']
            print(f"Bombero {firefighter_id}: posición actual {position}")
            
            # Agrega las posiciones al JSON del mapa (puedes ajustar según cómo estructures el JSON)
            map_data[f"Firefighter_{firefighter_id}"] = {
                "posicion_x": position[0],
                "posicion_y": position[1],
                "carrying_victim": carrying_victim
            }

        # Guarda el estado actualizado de la simulación en formato JSON
        save_json(map_data)

        # Pausa entre pasos (si es necesario)
        time.sleep(1)
        if not model.is_running:
            break

if __name__ == "__main__":
    main()
