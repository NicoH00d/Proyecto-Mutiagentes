# -*- coding: utf-8 -*-
"""FlashPoint.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SnqmGQhKoHTcvb6IP_MGWeIw0DCwx0bY
"""

#!pip install mesa
#!pip install numpy
#!pip install matplotlib
#!pip install pandas
#!pip install seaborn
#!pip install IPython

import mesa
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import IPython
from mesa import Agent, Model
from mesa.time import RandomActivation
from mesa.space import MultiGrid
from mesa.datacollection import DataCollector
import json
from typing import Any, Dict, List, Tuple, Optional

def parse_game_config(file_path):
    """Parsea la configuración del juego desde un archivo de texto."""
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # Extraer las 6 primeras líneas que contienen la matriz de paredes
    wall_matrix = [line.strip().split() for line in lines[:6]]

    # Verificar que la matriz de paredes se ha leído correctamente
    if not wall_matrix or len(wall_matrix) != 6:
        raise ValueError("Error: La matriz de paredes no tiene el tamaño correcto.")

    # Extraer las posiciones de los puntos de interés (víctimas y falsas alarmas)
    victims = []
    for line in lines[6:9]:  # Las siguientes 3 líneas
        x, y, v_type = line.strip().split()
        victims.append(((int(x), int(y)), v_type == 'v'))  # 'v' para víctima verdadera

    # Extraer los marcadores de fuego
    fire_markers = []
    for line in lines[9:19]:  # Las siguientes 10 líneas
        x, y = map(int, line.strip().split())
        fire_markers.append((x, y))

    # Extraer los marcadores de las puertas
    door_markers = []
    for line in lines[19:27]:  # Las siguientes 8 líneas
        x1, y1, x2, y2 = map(int, line.strip().split())
        door_markers.append(((x1, y1), (x2, y2)))

    # Extraer los puntos de entrada
    entry_points = []
    for line in lines[27:31]:  # Las últimas 4 líneas
        x, y = map(int, line.strip().split())
        entry_points.append((x, y))

    grid_connections = {}
    for y, row in enumerate(wall_matrix):
        for x, cell in enumerate(row):
            cell_position = (x, y)
            connections = []

            # Pared arriba (primer dígito)
            if cell[0] == '1' and y > 0:
                connections.append(((x, y), (x, y - 1), 5))  # Conecta con la celda de arriba
            # Pared izquierda (segundo dígito)
            if cell[1] == '1' and x > 0:
                connections.append(((x, y), (x - 1, y), 5))  # Conecta con la celda de la izquierda
            # Pared abajo (tercer dígito)
            if cell[2] == '1' and y < len(wall_matrix) - 1:
                connections.append(((x, y), (x, y + 1), 5))  # Conecta con la celda de abajo
            # Pared derecha (cuarto dígito)
            if cell[3] == '1' and x < len(row) - 1:
                connections.append(((x, y), (x + 1, y), 5))  # Conecta con la celda de la derecha

            grid_connections[cell_position] = connections

    return {
        "wall_matrix": wall_matrix,
        "grid_connections": grid_connections,
        "victims": victims,
        "fire_markers": fire_markers,
        "door_markers": door_markers,
        "entry_points": entry_points
    }

# Ejemplo de uso:
file_path = 'tablero.txt'  # Reemplaza con la ruta de tu archivo de texto
game_config = parse_game_config(file_path)

# Acceder a los diferentes elementos del diccionario
wall_matrix = game_config["wall_matrix"]
grid_connections = game_config["grid_connections"]
victim_positions = game_config["victims"]
fire_positions = game_config["fire_markers"]
door_positions = game_config["door_markers"]
entry_positions = game_config["entry_points"]

print("Matriz de paredes:", wall_matrix)
print("Conexiones generadas:", grid_connections)
print("Posiciones de víctimas:", victim_positions)
print("Posiciones de fuego:", fire_positions)
print("Posiciones de puertas:", door_positions)
print("Puntos de entrada:", entry_positions)


class BomberoAgent(Agent):
    def __init__(self, unique_id: int, model: 'FlashPointModel'):
        super().__init__(unique_id, model)
        self.ap = 4  # Puntos de acción iniciales
        self.max_ap = 8  # Máximo de AP acumulables
        self.position: Tuple[int, int] = (0, 0)
        self.carrying_victim = False
        self.estrategia: Optional[str] = None  # Estrategia asignada al bombero: 'buscar_poi', 'controlar_fuego', 'quitar_humo', 'romper_pared'

    def step(self):
        if self.estrategia:
            self.ejecutar_estrategia()
        self.acumular_ap()

    def acumular_ap(self):
        self.ap = min(self.ap + 4, self.max_ap)

    def mover(self, destino: Tuple[int, int]):
        costo = 1 if not self.model.get_cell_info(destino)["fuego"] else 2
        if self.ap >= costo:
            self.model.grid.move_agent(self, destino)
            self.position = destino
            self.ap -= costo

    def mover_victima(self, destino: Tuple[int, int]):
        if self.ap >= 2:
            self.model.grid.move_agent(self, destino)
            self.ap -= 2

    def abrir_puerta(self, pos: Tuple[int, int], direccion: str):
        if self.ap >= 2:
            self.model.set_door(pos, direccion)
            self.ap -= 2

    def extinguir_fuego(self, pos: Tuple[int, int]):
        if self.ap >= 2:
            self.model.extinguish_fire(pos)
            self.ap -= 2

    def destruir_pared(self, pos: Tuple[int, int], direccion: str):
        if self.ap >= 2:
            self.model.damage_wall(pos, direccion)
            self.ap -= 2

    def pasar_por_obstaculo(self, destino: Tuple[int, int]):
        if self.ap >= 1:
            self.mover(destino)
            self.ap -= 1

    def quitar_humo(self, pos: Tuple[int, int]):
        if self.ap >= 1:
            self.model.clear_smoke(pos)
            self.ap -= 1

    def ejecutar_estrategia(self):
        if self.estrategia == 'buscar_poi':
            self.estrategia_buscar_poi()
        elif self.estrategia == 'controlar_fuego':
            self.estrategia_controlar_fuego()
        elif self.estrategia == 'quitar_humo':
            self.estrategia_quitar_humo()
        elif self.estrategia == 'romper_pared':
            self.estrategia_romper_pared()

    def get_cell_info(self, pos: Tuple[int, int]) -> Dict[str, Any]:
        """Devuelve información sobre el estado de una celda específica."""
        cell_info = {
            "fuego": pos in self.fire_spots,
            "humo": pos in self.smoke_spots,
            "punto_interes": self.poi_dict.get(pos, {}).get("is_victim", False),
            "paredes": self.get_walls_info(pos),
            "puerta": self.is_doorway(pos)
        }
        return cell_info


    def estrategia_buscar_poi(self):
        poi_posiciones = [(x, y) for x in range(self.model.width)
                          for y in range(self.model.height)
                          if self.model.get_cell_info((x, y))["punto_interes"]]
        if poi_posiciones:
            destino = self.buscar_celda_cercana(poi_posiciones)
            if destino:
                self.mover(destino)

    def estrategia_controlar_fuego(self):
        fuego_posiciones = [(x, y) for x in range(self.model.width)
                            for y in range(self.model.height)
                            if self.model.get_cell_info((x, y))["fuego"]]
        if fuego_posiciones:
            destino = self.buscar_celda_cercana(fuego_posiciones)
            if destino:
                self.extinguir_fuego(destino)

    def estrategia_quitar_humo(self):
        humo_posiciones = [(x, y) for x in range(self.model.width)
                           for y in range(self.model.height)
                           if self.model.get_cell_info((x, y))["humo"]]
        if humo_posiciones:
            destino = self.buscar_celda_cercana(humo_posiciones)
            if destino:
                self.quitar_humo(destino)

    def estrategia_romper_pared(self):
        for direccion, (nx, ny) in self.get_adjacent_cells(self.position).items():
            if 0 <= nx < self.model.width and 0 <= ny < self.model.height:
                celda_objetivo = self.model.get_cell_info((nx, ny))
                if celda_objetivo["punto_interes"] and not celda_objetivo["paredes"][direccion].destroyed:
                    if abs(nx - self.position[0]) + abs(ny - self.position[1]) > 4:
                        self.destruir_pared(self.position, direccion)
                        return

        self.estrategia_buscar_poi()

    def buscar_celda_cercana(self, posiciones: list) -> Optional[Tuple[int, int]]:
        min_distancia = float('inf')
        mejor_pos = None
        for pos in posiciones:
            distancia = abs(pos[0] - self.position[0]) + abs(pos[1] - self.position[1])
            if distancia < min_distancia:
                min_distancia = distancia
                mejor_pos = pos
        return mejor_pos

    def get_adjacent_cells(self, pos: Tuple[int, int]) -> dict:
        x, y = pos
        return {
            "N": (x, y + 1),
            "S": (x, y - 1),
            "E": (x + 1, y),
            "O": (x - 1, y)
        }

from mesa import Model
from mesa.time import RandomActivation
from mesa.space import SingleGrid
from typing import List, Tuple, Dict, Set

class FlashPointModel(Model):
    def __init__(self, width: int, height: int, wall_matrix: List[str], victim_positions: List[Tuple[int, int, bool]],
                 initial_fire_positions: List[Tuple[int, int]], door_connections: List[Tuple[Tuple[int, int], Tuple[int, int]]],
                 exit_points: List[Tuple[int, int]], num_firefighters: int = 6):
        super().__init__()
        self.grid = SingleGrid(width, height, torus=False)
        self.schedule = RandomActivation(self)
        self.width = width
        self.height = height
        self.damage_markers = 0
        self.rescued_victims = 0
        self.lost_victims = 0
        self.victims_to_save = 7
        self.max_damage_threshold = 24
        self.fire_spots: Set[Tuple[int, int]] = set(initial_fire_positions)
        self.smoke_spots: Set[Tuple[int, int]] = set()
        self.poi_dict: Dict[Tuple[int, int], Dict[str, bool]] = {}
        self.grid_connections = {}
        self.wall_durability = {}
        self.simulation_step = 0
        self.is_running = True
        self.agents = []
        self.doorways = set(door_connections)
        self.exit_areas = set(exit_points)

        # Preparar el tablero de juego
        self.setup_grid(wall_matrix)
        self.deploy_agents(num_firefighters)
        self.place_victims(victim_positions)
        self.setup_fire(initial_fire_positions)

    def setup_grid(self, wall_matrix: List[str]) -> None:
        """Prepara la estructura de la cuadrícula, asignando las paredes y las puertas."""
        self.grid_connections = self.create_grid_structure(self.width, self.height, wall_matrix)
        self.convert_walls_to_doors(self.grid_connections, self.doorways)

    def create_grid_structure(self, width: int, height: int, wall_matrix: List[str]) -> Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]]:
        """Genera la estructura de la cuadrícula basada en el esquema de paredes."""
        grid_structure = {}
        direction_vectors = [(-1, 0), (0, -1), (1, 0), (0, 1)]  # Direcciones: Norte, Oeste, Sur, Este
        for x in range(width):
            for y in range(height):
                pos = (x, y)
                adjacents = []
                
                wall_info = wall_matrix[y][x]

                for i, vector in enumerate(direction_vectors):
                    adjacent_pos = (x + vector[0], y + vector[1])
                    if 0 <= adjacent_pos[0] < width and 0 <= adjacent_pos[1] < height:
                        travel_cost = 5 if wall_info[i] == '1' else 1
                        adjacents.append((adjacent_pos, travel_cost))
                        if travel_cost == 5:
                            self.wall_durability[(pos, adjacent_pos)] = 2

                grid_structure[pos] = adjacents
        
        print(grid_structure.keys())
        return grid_structure
        

    def convert_walls_to_doors(self, grid_structure: Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]],
                               door_positions: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> None:
        # Filtra las posiciones de puertas que están fuera de los límites de la cuadrícula
        valid_door_positions = [
            (cell1, cell2) for (cell1, cell2) in door_positions
            if (0 <= cell1[0] < self.width and 0 <= cell1[1] < self.height) and
               (0 <= cell2[0] < self.width and 0 <= cell2[1] < self.height)
        ]

        for cell1, cell2 in valid_door_positions:
            self.update_travel_cost(grid_structure, cell1, cell2, 2)
            self.update_travel_cost(grid_structure, cell2, cell1, 2)


    def update_travel_cost(self, grid_structure: Dict[Tuple[int, int], List[Tuple[Tuple[int, int], int]]],
                           from_pos: Tuple[int, int], to_pos: Tuple[int, int], new_cost: int) -> None:
        """Actualiza el costo de movimiento entre dos celdas en la cuadrícula."""
        for i, (adj, cost) in enumerate(grid_structure[from_pos]):
            if adj == to_pos:
                grid_structure[from_pos][i] = (adj, new_cost)
                break

    def deploy_agents(self, num_firefighters: int) -> None:
        """Despliega a los agentes bomberos en posiciones aleatorias y los coloca en la cuadrícula."""
        for i in range(num_firefighters):
            firefighter = BomberoAgent(i, self)
            while True:
                x, y = self.random.randrange(self.width), self.random.randrange(self.height)
                if self.grid.is_cell_empty((x, y)) and (x, y) not in self.fire_spots and (x, y) not in self.poi_dict:
                    break
            self.grid.place_agent(firefighter, (x, y))
            firefighter.position = (x, y)
            self.schedule.add(firefighter)
            self.agents.append(firefighter)

    def place_victims(self, victim_positions: List[Tuple[int, int, bool]]) -> None:
        """Coloca las víctimas en las posiciones iniciales en la cuadrícula."""
        for pos, is_victim in victim_positions:
            self.poi_dict[pos] = {"is_victim": is_victim, "revealed": False}

    def setup_fire(self, fire_positions: List[Tuple[int, int]]) -> None:
        """Coloca las posiciones iniciales de fuego en la cuadrícula."""
        for pos in fire_positions:
            self.fire_spots.add(pos)

    def advance_simulation(self):
        """Avanza un paso en la simulación."""
        if self.is_running:
            self.spread_fire()
            self.schedule.step()
            self.evaluate_game_over_conditions()
            self.simulation_step += 1

    def spread_fire(self) -> None:
        """Gestiona la propagación del fuego, convirtiendo humo en fuego y manejando explosiones."""
        fire_roll = (self.random.randrange(self.width), self.random.randrange(self.height))
        self.add_smoke(fire_roll)
        self.trigger_flashover()

    def add_smoke(self, pos: Tuple[int, int]) -> None:
        """Agrega humo a una celda, o lo convierte en fuego si ya tiene humo."""
        if pos in self.fire_spots:
            self.handle_explosion(pos)
        elif pos in self.smoke_spots:
            self.turn_smoke_into_fire(pos)
        else:
            self.smoke_spots.add(pos)
            if any(self.is_adjacent(pos, fire_pos) for fire_pos in self.fire_spots):
                self.turn_smoke_into_fire(pos)

    def turn_smoke_into_fire(self, pos: Tuple[int, int]) -> None:
        """Convierte el humo en fuego en una posición específica."""
        self.smoke_spots.remove(pos)
        self.fire_spots.add(pos)
        if pos in self.poi_dict:
            self.lose_victim(pos)

    def handle_explosion(self, pos: Tuple[int, int]) -> None:
        """Gestiona una explosión en una celda, afectando paredes, puertas y propagando el fuego."""
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dx, dy in directions:
            adjacent_pos = (pos[0] + dx, pos[1] + dy)
            if adjacent_pos in self.grid_connections:
                if self.is_wall_between(pos, adjacent_pos):
                    self.weaken_wall(pos, adjacent_pos)
                elif self.is_door_between(pos, adjacent_pos):
                    self.weaken_door(pos, adjacent_pos)
                elif adjacent_pos in self.fire_spots:
                    self.trigger_shockwave(adjacent_pos, (dx, dy))
                else:
                    self.place_fire_or_switch_smoke(adjacent_pos)

    def place_fire_or_switch_smoke(self, pos: Tuple[int, int]) -> None:
        """Coloca fuego o convierte humo en fuego en una posición específica."""
        if pos in self.smoke_spots:
            self.turn_smoke_into_fire(pos)
        else:
            self.fire_spots.add(pos)
            if pos in self.poi_dict:
                self.lose_victim(pos)

    def trigger_shockwave(self, start_pos: Tuple[int, int], direction: Tuple[int, int]) -> None:
        """Propaga la onda expansiva de una explosión, afectando las celdas en la dirección dada."""
        current_pos = start_pos
        while True:
            next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
            if not self.is_valid_position(next_pos):
                break
            if next_pos not in self.fire_spots:
                if next_pos in self.smoke_spots:
                    self.turn_smoke_into_fire(next_pos)
                elif self.is_wall_between(current_pos, next_pos):
                    self.weaken_wall(current_pos, next_pos)
                    break
                elif self.is_door_between(current_pos, next_pos):
                    self.weaken_door(current_pos, next_pos)
                    break
                else:
                    self.place_fire_or_switch_smoke(next_pos)
                    break
            current_pos = next_pos

    def trigger_flashover(self) -> None:
        """Simula el fenómeno del flashover, donde el fuego se propaga al humo adyacente."""
        flashover_occurred = True
        while flashover_occurred:
            flashover_occurred = False
            for smoke_pos in list(self.smoke_spots):
                if any(self.is_adjacent(smoke_pos, fire_pos) for fire_pos in self.fire_spots):
                    self.turn_smoke_into_fire(smoke_pos)
                    flashover_occurred = True

    def lose_victim(self, pos: Tuple[int, int]) -> None:
        """Gestiona la pérdida de una víctima en una posición específica."""
        if pos in self.poi_dict:
            if self.poi_dict[pos]["is_victim"] and not self.poi_dict[pos]["revealed"]:
                self.lost_victims += 1
            del self.poi_dict[pos]

    def evaluate_game_over_conditions(self) -> None:
        """Evalúa si se ha alcanzado una condición de fin de juego."""
        if self.damage_markers >= self.max_damage_threshold:
            self.is_running = False
            print("Fin del Juego: El edificio ha colapsado.")
        elif self.lost_victims >= 4:
            self.is_running = False
            print("Fin del Juego: Se han perdido demasiadas víctimas.")
        elif self.rescued_victims >= self.victims_to_save:
            self.is_running = False
            print("Fin del Juego: Todas las víctimas han sido rescatadas.")
        elif len(self.agents) == 0:
            self.is_running = False
            print("Fin del Juego: No quedan más bomberos.")

    def is_valid_position(self, pos: Tuple[int, int]) -> bool:
        """Comprueba si una posición está dentro de los límites de la cuadrícula."""
        return 0 <= pos[0] < self.width and 0 <= pos[1] < self.height

    def is_adjacent(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> bool:
        """Determina si dos posiciones son adyacentes en la cuadrícula."""
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1]) == 1

    def is_wall_between(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> bool:
        """Comprueba si hay una pared entre dos celdas adyacentes."""
        return any(adj == adj_pos and cost == 5 for adj, cost in self.grid_connections.get(pos, []))

    def is_door_between(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> bool:
        """Comprueba si hay una puerta entre dos celdas adyacentes."""
        return any(adj == adj_pos and cost == 2 for adj, cost in self.grid_connections.get(pos, []))

    def weaken_wall(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> None:
        """Debilita una pared entre dos celdas, eventualmente destruyéndola."""
        if self.is_wall_between(pos, adj_pos):
            wall_key = (pos, adj_pos) if (pos, adj_pos) in self.wall_durability else (adj_pos, pos)
            self.wall_durability[wall_key] -= 1
            self.damage_markers += 1
            if self.wall_durability[wall_key] == 0:
                self.update_travel_cost(self.grid_connections, pos, adj_pos, 1)
                self.update_travel_cost(self.grid_connections, adj_pos, pos, 1)
                del self.wall_durability[wall_key]
                print(f"La pared entre {pos} y {adj_pos} ha sido destruida.")

    def weaken_door(self, pos: Tuple[int, int], adj_pos: Tuple[int, int]) -> None:
        """Debilita una puerta entre dos celdas, eventualmente convirtiéndola en un camino abierto."""
        if self.is_door_between(pos, adj_pos):
            self.update_travel_cost(self.grid_connections, pos, adj_pos, 1)
            self.update_travel_cost(self.grid_connections, adj_pos, pos, 1)

    def get_simulation_state(self) -> Dict:
        """Devuelve el estado actual de la simulación."""
        return {
            "step": self.simulation_step,
            "grid_connections": self.grid_connections,
            "damage_markers": self.damage_markers,
            "rescued_victims": self.rescued_victims,
            "lost_victims": self.lost_victims,
            "running": self.is_running,
            "fire_locations": list(self.fire_spots),
            "smoke_locations": list(self.smoke_spots),
            "poi_locations": [{"position": pos, "revealed": info["revealed"]} for pos, info in self.poi_dict.items()],
            "firefighter_positions": [{"id": agent.unique_id, "position": agent.position, "carrying_victim": agent.carrying_victim} for agent in self.agents if isinstance(agent, BomberoAgent)]
        }

if __name__ == "__main__":
    # Leer los datos desde el archivo de configuración usando el parser
    config_path = "tablero.txt"  # Ruta al archivo de configuración
    game_config = parse_game_config(config_path)

    # Extraer la información del parser
    wall_matrix = game_config["wall_matrix"]
    victim_positions = game_config["victims"]
    initial_fire_positions = game_config["fire_markers"]
    door_connections = game_config["door_markers"]
    exit_points = game_config["entry_points"]
    GRID_WIDTH = 8
    GRID_HEIGHT = 6
    # Inicializar el modelo con los datos extraídos
    model = FlashPointModel(GRID_WIDTH, GRID_HEIGHT, wall_matrix, victim_positions, initial_fire_positions, door_connections, exit_points)

import json
import time

# Clase Cell que nos ayuda a guardar información
class Cell():
    def __init__(self, x, y, wall):
        # posición
        self.pos = (x, y)

        # valor de los muros
        self.up = wall[0] == '1'
        self.left = wall[1] == '1'
        self.down = wall[2] == '1'
        self.right = wall[3] == '1'

        # valor de los puntos de interés 1 si es falsa alarma, 2 si es una víctima
        self.poi = 0

        # valor del fuego 1 si es humo, 2 si es fuego
        self.fire = 0

        # arreglo con la posición de la casilla donde se conecta con puerta
        self.door = []

        # True si la casilla es una entrada a la estructura
        self.entrance = False

# Abrimos el archivo txt
with open('tablero.txt', 'r') as map_file:
    text = map_file.read().splitlines()

# Obtenemos los valores de los muros
walls = []
for line in text[:6]:
    wall_segments = line.split()
    walls.extend(wall_segments)

# Obtenemos los valores de los puntos de interés (POI)
pois = []
for line in text[6:9]:
    pos_poi_x = line[0]
    pos_poi_y = line[2]
    pos_poi_state = line[4]
    pois.append((pos_poi_x, pos_poi_y, pos_poi_state))

# Obtenemos los valores del fuego
fires = []
for line in text[9:19]:
    pos_fire_x = line[0]
    pos_fire_y = line[2]
    fires.append((pos_fire_x, pos_fire_y))

# Obtenemos las casillas que están conectadas por una puerta
doors = []
for line in text[19:27]:
    pos_doorA_x = line[0]
    pos_doorA_y = line[2]
    pos_doorB_x = line[4]
    pos_doorB_y = line[6]
    doors.append(((pos_doorA_x, pos_doorA_y), (pos_doorB_x, pos_doorB_y)))

# Obtenemos las posiciones de las entradas
entrances = []
for line in text[27:]:
    pos_entrance_x = line[0]
    pos_entrance_y = line[2]
    entrances.append((pos_entrance_x, pos_entrance_y))
    
# Inicializamos las celdas
cells = []
for i in range(6):
    for j in range(8):
        w = walls.pop(0)
        c = Cell(i + 1, j + 1, w)
        cells.append(c)

        if (str(i + 1), str(j + 1), 'v') in pois:
            c.poi = 2
        elif (str(i + 1), str(j + 1), 'f') in pois:
            c.poi = 1

        if (str(i + 1), str(j + 1)) in fires:
            c.fire = 2

        for d in doors:
            if (str(i + 1), str(j + 1)) == d[0]:
                c.door = d[1]

        if (str(i + 1), str(j + 1)) in entrances:
            c.entrance = True

# Diccionario con la composición inicial de celdas
map_data = {}

for c in cells:
    cell_key = f"Cell {c.pos[0]}{c.pos[1]}"
    
    if cell_key not in map_data:
        map_data[cell_key] = {
            "posicion_x": c.pos[0],
            "posicion_y": c.pos[1],
            "muro_arriba": c.up,
            "muro_izquierda": c.left,
            "muro_abajo": c.down,
            "muro_derecha": c.right,
            "punto_interes": c.poi,
            "fuego": c.fire,
            "puerta": c.door,
            "entrada": c.entrance,
            "coordenadas_poi": [],
            "coordenadas_victimas": [],
            "coordenadas_fuego": [],
            "coordenadas_entradas": []
        }
    
    # Actualizar coordenadas de puntos de interés
    if c.poi == 2:  # Víctima
        map_data[cell_key]["coordenadas_victimas"].append(c.pos)
        map_data[cell_key]["coordenadas_poi"].append(c.pos)
    elif c.poi == 1:  # Falsa alarma
        # Solo se agrega si no hay fuego o víctimas en la misma celda
        if map_data[cell_key]["fuego"] == 0 and not map_data[cell_key]["coordenadas_victimas"]:
            map_data[cell_key]["coordenadas_poi"].append(c.pos)
    
    # Actualizar coordenadas de fuego
    if c.fire == 2:  # Fuego
        map_data[cell_key]["coordenadas_fuego"].append(c.pos)
    
    # Actualizar coordenadas de entradas
    if c.entrance:
        map_data[cell_key]["coordenadas_entradas"].append(c.pos)


def save_json(map_data):
    # Guarda el JSON en un archivo (sobrescribiendo en cada paso)
    with open('simulation_state.json', 'w') as outfile:
        json.dump(map_data, outfile)

def main():
    # Procesa el archivo del mapa
    #map_data = process_map_file('tablero.txt')

    # Correr la simulación por 100 pasos
    for step in range(100):
        game_state = model.advance_simulation()  # Aquí avanza la simulación
        print(f"Estado del juego en el paso {step + 1}:")
        
        # Obtén el estado actual del tablero
        current_state = model.get_simulation_state()

        # Integra la posición de los bomberos en el mapa
        for firefighter in current_state['firefighter_positions']:
            firefighter_id = firefighter['id']
            position = firefighter['position']
            carrying_victim = firefighter['carrying_victim']
            
            # Agrega las posiciones al JSON del mapa (puedes ajustar según cómo estructures el JSON)
            map_data[f"Firefighter_{firefighter_id}"] = {
                "posicion_x": position[0],
                "posicion_y": position[1],
                "carrying_victim": carrying_victim
            }

        # Guarda el estado actualizado de la simulación en formato JSON
        save_json(map_data)

        # Pausa entre pasos (si es necesario)
        time.sleep(3)
        if not model.is_running:
            break

if __name__ == "__main__":
    main()
